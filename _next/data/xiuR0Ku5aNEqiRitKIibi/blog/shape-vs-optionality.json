{"pageProps":{"post":{"title":"Decomplecting shape and optionality","date":"2022-08-28","description":"Separation between the shape of an entity and the optionality of its fields as a way of improving reusability and simplicity.","thumbnail":{"url":"/images/shape-vs-optionality.jpeg","attribution":{"name":"Alfons Morales","url":"https://unsplash.com/@alfonsmc10?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"}},"tags":["schemas","simplicity","information"],"series":{"name":"Schemas","order":1},"filePath":"shape-vs-optionality.mdx","slug":"shape-vs-optionality","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    h2: \"h2\",\n    p: \"p\",\n    a: \"a\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {Quote} = _components;\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Decomplecting shape and optionality\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"TLDR;\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Defining a schema for a given entity we tend to define what attributes this entity has, what types or invariants\\neach of those attributes have and what attributes are required or optional.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this post I am exposing that the shape of the data (attributes and their types) need to be discussed separately\\nfrom their optionality. If we discuss and define them together we are complecting two concepts that should we separately\\nthem the simplicity, clarity and reusability of our system will be greatly improved.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Introduction\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Apart from my own experience some of the concepts described in this post are also described by well-known\\nengineers like Rich Hickey in \", _jsx(_components.a, {\n        href: \"https://www.youtube.com/watch?v=YR5WdGrpoug\",\n        children: \"Maybe Not\"\n      }), \" available in my \", _jsx(_components.a, {\n        href: \"/recommended-resources\",\n        children: \"recommended resources\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I will use a Blog Post as the example for the model but again, this applied to any entity we can think of.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Defining a blog Post\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Defining the shape\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We need to define the data model of a Post that will be used in a blog (any blog).\\nAfter some meetings we agree that we need the following fields:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"- ID: uuid that will identiy the post uniquely\\n- Title: short text to be shown in links and use as slug\\n- Body: text where the post will be written to\\n- Tags: list of keywords to find similar posts\\n- PublishedAt: datetime when the post was published\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Defining the optionality\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Once we agree on the shape of the Post entity, we start a new discussion:\"\n    }), \"\\n\", _jsx(Quote, {\n      children: \"What fields are required and what are optional?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It seems like all are required since we would need to show all of them in the blog. So we move on\\nand decide that we will make all columns NOT NULL in the DB.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"After some time discussing, a junior developer asks:\"\n    }), \"\\n\", _jsx(Quote, {\n      children: \"What about drafts?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Another discussion starts about \\\"What is a draft?\\\". Should a draft have the same shape as the Post but with \\\"nullable\\\"\\nfields? what are the required fields in this case?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"After some time discussing the team decided to have 2 very similar tables one with drafts where columns (except id) are NULLABLE and\\nposts where all columns are required.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Consequences\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are two entities that somehow are too closely related.\\nThis lead to some problems:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"- ⛔ Entity proliferation. We have all been in projects with too many entities that seem to describe almost the same thing.\\n- ⛔ Change management: New fields in Posts will require new fields in Drafts almost always.\\n- ⛔ Event ambiguity: If we use EDA or similar, are Drafts / Posts events sent to the same topic? are they really different?\\n  how can we see the history of a Post if it starts as a Draft?\\n- ✅ DB leverage: we can use DB schemas to control whether the data being stored is correct or not.\\n- ...\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Rolling back\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Defining the shape of the entity is something we cannot avoid (or if we can we should not). Having\\na clear description of what an Entity is, and what parts form it is desirable specially if the names\\nand types of the fields are defined by the Domain experts.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The problem started when we discussed about the optionality of the fields. When we started discussion:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"What fields are required and what are optional?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The answer to this question should have been another question:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(Quote, {\n        children: \"When?\"\n      }), \"\\n(as engineers we should ask \", _jsx(_components.code, {\n        children: \"when\"\n      }), \" more often than we do)\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Optionality per operation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"What are the operations we can do for/on Posts?\\nLet's say that we can do 3 operations with Posts:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"- Save the post\\n- Publish the post\\n- Unpublish the post\\n- Delete the post\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rules are:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"- We cannot edit a post if it is published\\n- We cannot delete a post if it is published\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Optionality has to do with the operation we want to perform on/with a given Envity.\\nFor example, asking:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"What are the required fields when publishing a post?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The conclusion would be very similar to the \", _jsx(_components.a, {\n        href: \"#defining-the-optionality\",\n        children: \"previous discusion\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But if we discussed about what are the required field when saving a Post then the answer will be something around: None.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can let users save the posts in whatever state they are (missing tags, missing body, etc)\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Consequences\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There is only one entity that goes through different states until it is published.\\nThe benefits are:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"- ✅ Entity proliferation: so far under control.\\n- ✅ Change management: there is only one entity we need to think about.\\n- ✅ Event unambiguity: all events belong to the same entity so we have one topic and one history line.\\n- ⛔ DB leverage: DB Schema cannot be leveraged to control required fields/columns. The control is in the application layer.\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Appendix\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If we changed the rules and we allowed to edit a post while it is published when discussing the optionality during the \", _jsx(_components.code, {\n        children: \"save\"\n      }), \" operation\\nwe would need to ask \", _jsx(_components.code, {\n        children: \"When\"\n      }), \" again.\\nWhen the post is already published the requirements will be different than when the post is not published yet (or was unpublished).\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"markdown":"# Decomplecting shape and optionality\n\n## TLDR;\n\nDefining a schema for a given entity we tend to define what attributes this entity has, what types or invariants\neach of those attributes have and what attributes are required or optional.\n\nIn this post I am exposing that the shape of the data (attributes and their types) need to be discussed separately\nfrom their optionality. If we discuss and define them together we are complecting two concepts that should we separately\nthem the simplicity, clarity and reusability of our system will be greatly improved.\n\n## Introduction\n\nApart from my own experience some of the concepts described in this post are also described by well-known\nengineers like Rich Hickey in [Maybe Not](https://www.youtube.com/watch?v=YR5WdGrpoug) available in my [recommended resources](/recommended-resources)\n\nI will use a Blog Post as the example for the model but again, this applied to any entity we can think of.\n\n## Defining a blog Post\n\n### Defining the shape\n\nWe need to define the data model of a Post that will be used in a blog (any blog).\nAfter some meetings we agree that we need the following fields:\n\n```text\n- ID: uuid that will identiy the post uniquely\n- Title: short text to be shown in links and use as slug\n- Body: text where the post will be written to\n- Tags: list of keywords to find similar posts\n- PublishedAt: datetime when the post was published\n```\n\n### Defining the optionality\n\nOnce we agree on the shape of the Post entity, we start a new discussion:\n\n<Quote>What fields are required and what are optional?</Quote>\n\nIt seems like all are required since we would need to show all of them in the blog. So we move on\nand decide that we will make all columns NOT NULL in the DB.\n\nAfter some time discussing, a junior developer asks:\n\n<Quote>What about drafts?</Quote>\n\nAnother discussion starts about \"What is a draft?\". Should a draft have the same shape as the Post but with \"nullable\"\nfields? what are the required fields in this case?\n\nAfter some time discussing the team decided to have 2 very similar tables one with drafts where columns (except id) are NULLABLE and\nposts where all columns are required.\n\n### Consequences\n\nThere are two entities that somehow are too closely related.\nThis lead to some problems:\n\n```text\n- ⛔ Entity proliferation. We have all been in projects with too many entities that seem to describe almost the same thing.\n- ⛔ Change management: New fields in Posts will require new fields in Drafts almost always.\n- ⛔ Event ambiguity: If we use EDA or similar, are Drafts / Posts events sent to the same topic? are they really different?\n  how can we see the history of a Post if it starts as a Draft?\n- ✅ DB leverage: we can use DB schemas to control whether the data being stored is correct or not.\n- ...\n```\n\n## Rolling back\n\nDefining the shape of the entity is something we cannot avoid (or if we can we should not). Having\na clear description of what an Entity is, and what parts form it is desirable specially if the names\nand types of the fields are defined by the Domain experts.\n\nThe problem started when we discussed about the optionality of the fields. When we started discussion:\n\nWhat fields are required and what are optional?\n\nThe answer to this question should have been another question:\n\n<Quote>When?</Quote>\n(as engineers we should ask `when` more often than we do)\n\n### Optionality per operation\n\nWhat are the operations we can do for/on Posts?\nLet's say that we can do 3 operations with Posts:\n\n```\n- Save the post\n- Publish the post\n- Unpublish the post\n- Delete the post\n```\n\nRules are:\n\n```\n- We cannot edit a post if it is published\n- We cannot delete a post if it is published\n```\n\nOptionality has to do with the operation we want to perform on/with a given Envity.\nFor example, asking:\n\nWhat are the required fields when publishing a post?\n\nThe conclusion would be very similar to the [previous discusion](#defining-the-optionality).\n\nBut if we discussed about what are the required field when saving a Post then the answer will be something around: None.\n\nWe can let users save the posts in whatever state they are (missing tags, missing body, etc)\n\n### Consequences\n\nThere is only one entity that goes through different states until it is published.\nThe benefits are:\n\n```text\n- ✅ Entity proliferation: so far under control.\n- ✅ Change management: there is only one entity we need to think about.\n- ✅ Event unambiguity: all events belong to the same entity so we have one topic and one history line.\n- ⛔ DB leverage: DB Schema cannot be leveraged to control required fields/columns. The control is in the application layer.\n```\n\n## Appendix\n\nIf we changed the rules and we allowed to edit a post while it is published when discussing the optionality during the `save` operation\nwe would need to ask `When` again.\nWhen the post is already published the requirements will be different than when the post is not published yet (or was unpublished).\n"}},"__N_SSG":true}