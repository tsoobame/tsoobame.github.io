<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Tsoobame - Graphql Schema Stitching</title><meta name="next-head-count" content="3"/><title>Tsoobame</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Z67DVHFVCM"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-Z67DVHFVCM', {
              page_path: window.location.pathname,
            });
          </script><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8646ebd196ee32a0.js" defer=""></script><script src="/_next/static/chunks/framework-9b5d6ec4444c80fa.js" defer=""></script><script src="/_next/static/chunks/main-acfafc49f148be44.js" defer=""></script><script src="/_next/static/chunks/pages/_app-19cf46ff209d7e2e.js" defer=""></script><script src="/_next/static/chunks/181-fa4e5b0dcaf48e99.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-4afd1af938b86671.js" defer=""></script><script src="/_next/static/bI8TJphBv-0RVteqVUZQm/_buildManifest.js" defer=""></script><script src="/_next/static/bI8TJphBv-0RVteqVUZQm/_ssgManifest.js" defer=""></script><style id="jss-server-side">.jss1 {
  background: linear-gradient(90deg, #00766c, #0077c2);
}
.jss3 {
  overflow-x: auto;
  justify-content: space-between;
}
.jss4 {
  padding: 8px;
  flex-shrink: 0;
}
.jss5 {
  top: 0;
  left: 0;
  right: 0;
  width: 100%;
  z-index: 99;
  position: fixed;
}
.jss6 {
  color: #FFFFFF;
  width: 100%;
  bottom: 0;
  padding: 16px 0px;
  z-index: 99;
  position: fixed;
  background: linear-gradient(90deg, #00766c, #0077c2);
}</style></head><body style="padding:0;margin:0"><div id="__next"><style data-emotion="css 1a51u83">.css-1a51u83{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;box-sizing:border-box;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;position:static;background-color:#26a69a;color:#FFFFFF;}</style><style data-emotion="css 1rhdqfh">.css-1rhdqfh{background-color:#FFFFFF;color:#263238;-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;box-shadow:0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;box-sizing:border-box;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;position:static;background-color:#26a69a;color:#FFFFFF;}</style><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionStatic jss5 css-1rhdqfh" style="padding:0"><style data-emotion="css i6s8oy">.css-i6s8oy{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding-left:16px;padding-right:16px;min-height:56px;}@media (min-width:600px){.css-i6s8oy{padding-left:24px;padding-right:24px;}}@media (min-width:0px){@media (orientation: landscape){.css-i6s8oy{min-height:48px;}}}@media (min-width:600px){.css-i6s8oy{min-height:64px;}}</style><div class="MuiToolbar-root MuiToolbar-gutters MuiToolbar-regular jss1 css-i6s8oy"><style data-emotion="css 18zcnv2">.css-18zcnv2{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1.5rem;line-height:1.334;letter-spacing:0em;text-align:center;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:inherit;}</style><h2 class="MuiTypography-root MuiTypography-h5 MuiTypography-alignCenter MuiTypography-noWrap jss2 css-18zcnv2"><style data-emotion="css 1cik1k3">.css-1cik1k3{-webkit-text-decoration:underline;text-decoration:underline;color:inherit;}.css-1cik1k3:hover{text-decoration-color:inherit;}</style><style data-emotion="css 1c0wj8h">.css-1c0wj8h{margin:0;color:inherit;-webkit-text-decoration:underline;text-decoration:underline;color:inherit;}.css-1c0wj8h:hover{text-decoration-color:inherit;}</style><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-1c0wj8h" style="text-decoration:none" href="/">tsoobame</a></h2><style data-emotion="css 1t6c9ts">.css-1t6c9ts{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}@media (min-width:0px){.css-1t6c9ts{display:none;}}@media (min-width:900px){.css-1t6c9ts{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}</style><div class="MuiBox-root css-1t6c9ts"><style data-emotion="css qh4u80">.css-qh4u80{font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:500;font-size:0.875rem;line-height:1.75;letter-spacing:0.02857em;text-transform:uppercase;min-width:64px;padding:6px 8px;border-radius:4px;-webkit-transition:background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:#26a69a;margin-top:16px;margin-bottom:16px;color:#FFFFFF;display:block;}.css-qh4u80:hover{-webkit-text-decoration:none;text-decoration:none;background-color:rgba(38, 166, 154, 0.04);}@media (hover: none){.css-qh4u80:hover{background-color:transparent;}}.css-qh4u80.Mui-disabled{color:rgba(0, 0, 0, 0.26);}</style><style data-emotion="css 19ut74o">.css-19ut74o{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:500;font-size:0.875rem;line-height:1.75;letter-spacing:0.02857em;text-transform:uppercase;min-width:64px;padding:6px 8px;border-radius:4px;-webkit-transition:background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:#26a69a;margin-top:16px;margin-bottom:16px;color:#FFFFFF;display:block;}.css-19ut74o::-moz-focus-inner{border-style:none;}.css-19ut74o.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-19ut74o{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-19ut74o:hover{-webkit-text-decoration:none;text-decoration:none;background-color:rgba(38, 166, 154, 0.04);}@media (hover: none){.css-19ut74o:hover{background-color:transparent;}}.css-19ut74o.Mui-disabled{color:rgba(0, 0, 0, 0.26);}</style><button class="MuiButtonBase-root MuiButton-root MuiButton-text MuiButton-textPrimary MuiButton-sizeMedium MuiButton-textSizeMedium css-19ut74o" tabindex="0" type="button"><a style="color:white;text-decoration:none" href="/blog">Blog</a></button><button class="MuiButtonBase-root MuiButton-root MuiButton-text MuiButton-textPrimary MuiButton-sizeMedium MuiButton-textSizeMedium css-19ut74o" tabindex="0" type="button"><a style="color:white;text-decoration:none" href="/about">About</a></button><button class="MuiButtonBase-root MuiButton-root MuiButton-text MuiButton-textPrimary MuiButton-sizeMedium MuiButton-textSizeMedium css-19ut74o" tabindex="0" type="button"><a style="color:white;text-decoration:none" href="/projects">Projects</a></button><button class="MuiButtonBase-root MuiButton-root MuiButton-text MuiButton-textPrimary MuiButton-sizeMedium MuiButton-textSizeMedium css-19ut74o" tabindex="0" type="button"><a style="color:white;text-decoration:none" href="/recommended-resources">Resources</a></button></div></div></header><div class="MuiBox-root css-0" style="position:relative;width:90%;padding-left:24px;padding-right:24px;margin-top:80px;margin-bottom:90px;z-index:2"><div class="MuiBox-root css-0" style="width:auto;padding:12px"><style data-emotion="css 15bqboc">.css-15bqboc{box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;width:100%;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;}</style><div class="MuiGrid-root MuiGrid-container css-15bqboc"><style data-emotion="css 13ps8n2">.css-13ps8n2{box-sizing:border-box;margin:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}@media (min-width:600px){.css-13ps8n2{-webkit-flex-basis:100%;-ms-flex-preferred-size:100%;flex-basis:100%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:100%;}}@media (min-width:900px){.css-13ps8n2{-webkit-flex-basis:25%;-ms-flex-preferred-size:25%;flex-basis:25%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:25%;}}@media (min-width:1200px){.css-13ps8n2{-webkit-flex-basis:25%;-ms-flex-preferred-size:25%;flex-basis:25%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:25%;}}@media (min-width:1536px){.css-13ps8n2{-webkit-flex-basis:25%;-ms-flex-preferred-size:25%;flex-basis:25%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:25%;}}</style><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-sm-12 MuiGrid-grid-md-3 css-13ps8n2" style="padding:6px"><div><style data-emotion="css t1nuxs">.css-t1nuxs{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1.5rem;line-height:1.334;letter-spacing:0em;margin-bottom:0.35em;}</style><h5 class="MuiTypography-root MuiTypography-h5 MuiTypography-gutterBottom css-t1nuxs">Posts </h5><ul style="list-style-type:none"><li><style data-emotion="css 9l3uo3">.css-9l3uo3{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class="MuiTypography-root MuiTypography-body1 css-9l3uo3"><a style="text-decoration:none;color:gray" href="/blog/data-loader">Understanding data loader</a></p></li><li><p class="MuiTypography-root MuiTypography-body1 css-9l3uo3"><a style="text-decoration:none;color:gray" href="/blog/graphql-schema-stitching">Graphql Schema Stitching</a></p></li><li><p class="MuiTypography-root MuiTypography-body1 css-9l3uo3"><a style="text-decoration:none;color:gray" href="/blog/shape-vs-optionality">Decomplecting shape and optionality</a></p></li></ul></div></div><style data-emotion="css 1xd5sck">.css-1xd5sck{box-sizing:border-box;margin:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-basis:100%;-ms-flex-preferred-size:100%;flex-basis:100%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:100%;}@media (min-width:600px){.css-1xd5sck{-webkit-flex-basis:100%;-ms-flex-preferred-size:100%;flex-basis:100%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:100%;}}@media (min-width:900px){.css-1xd5sck{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:1200px){.css-1xd5sck{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:1536px){.css-1xd5sck{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}</style><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-md-9 css-1xd5sck"><img src="/images/graphql-schema-stitching.jpeg" style="height:200px;object-fit:cover" width="100%" height="200"/><p class="MuiTypography-root MuiTypography-body1 css-9l3uo3">⏱ <!-- -->5 min read</p><div class="MuiBox-root css-0"><style data-emotion="css 6s8q25">.css-6s8q25{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:3rem;line-height:1.167;letter-spacing:0em;margin-bottom:0.35em;}</style><h3 class="MuiTypography-root MuiTypography-h3 MuiTypography-gutterBottom css-6s8q25" style="margin-top:24px">Graphql Schema Stitching</h3>
<style data-emotion="css wje1bd">.css-wje1bd{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;margin-bottom:16px;}</style><p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">I am going to write a short (?) post about how to create a simple API Gateway that exposes two services using Graphql Stitching. I am assuming some knowledge about graphql and Apollo Server.
We will use express, nodejs and apollo for the service and a technique called schema stitching.
If you want to learn more about Graphql you can go to the official site.</p>
<style data-emotion="css gtvj52">.css-gtvj52{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:2.125rem;line-height:1.235;letter-spacing:0.00735em;margin-bottom:0.35em;}</style><h4 class="MuiTypography-root MuiTypography-h4 MuiTypography-gutterBottom css-gtvj52" style="margin-top:24px">Why do we need Api gateways and schema stitching</h4>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">I will write a whole post about the reasons we had to use Graphql in our services and in our Api Gateway.
Here I am offering a short explanation:
In real world scenarios we are creating independent and autonomous (micro)services. The less data they share, the less they need to call each other and the less coupled they are, the better.
Many times a service manages entities (or parts of entities) that hold an id about another entity but does not need to know more details. For example an inventory service might manage productID and available units, but does not need to know about the name of the product or about its price.
Inventory service will be able to run all its operations and apply the rules it manages without requesting information to any other service.
Users, on the other hand, will need to see this scattered data together in one screen. In order to avoid too many requests from the UI, an API Gateway can offer a single endpoint where UI can request the data needed for a specific functionality/screen in one request, and the Gateway can orchestrate the calls to other services, cache results if needed, etc.</p>
<h4 class="MuiTypography-root MuiTypography-h4 MuiTypography-gutterBottom css-gtvj52" style="margin-top:24px">Let&#x27;s start working</h4>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">Let&#x27;s create a folder as the root for our project:</p>
<pre><code class="language-shell">mkdir graphql-stitching
cd graphql-stitching
</code></pre>
<h4 class="MuiTypography-root MuiTypography-h4 MuiTypography-gutterBottom css-gtvj52" style="margin-top:24px">Creating the songs service</h4>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">We are going to create a simple service that offers data about songs.</p>
<pre><code class="language-shell">mkdir songs
cd songs
npm init -y
npm install express graphql apollo-server-express body-parser
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">We are going to create our schema first:</p>
<pre><code class="language-shell">touch schema.js
</code></pre>
<style data-emotion="css 4an0mh">.css-4an0mh{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:500;font-size:1.25rem;line-height:1.6;letter-spacing:0.0075em;margin-bottom:0.35em;}</style><h6 class="MuiTypography-root MuiTypography-h6 MuiTypography-gutterBottom css-4an0mh" style="margin-top:24px">schema.js</h6>
<pre><code class="language-javascript">const { makeExecutableSchema } = require(&quot;graphql-tools&quot;);
const gql = require(&quot;graphql-tag&quot;);

const songs = [
  { id: 1, title: &quot;I will always love you&quot; },
  { id: 2, title: &quot;Lose yourself&quot; },
  { id: 3, title: &quot;Eye of the tiger&quot; },
  { id: 4, title: &quot;Men in Black&quot; },
  { id: 5, title: &quot;The power of love&quot; },
  { id: 6, title: &quot;My Heart will go on&quot; },
];

const typeDefs = gql`
  type Query {
    songs: [Song]
    song(songId: ID!): Song
  }
  type Song {
    id: ID
    title: String
  }
`;

const resolvers = {
  Query: {
    songs: () =&gt; {
      return songs;
    },
    song(parent, args, context, info) {
      return songs.find((song) =&gt; song.id === Number(args.songId));
    },
  },
};

module.exports = makeExecutableSchema({
  typeDefs,
  resolvers,
});
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">We are defining a list of songs.
The type Song (id, title) and two queries for getting all songs and one song by id.</p>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">Let&#x27;s create the api:</p>
<pre><code class="language-shell">touch index.js
</code></pre>
<h5 class="MuiTypography-root MuiTypography-h5 MuiTypography-gutterBottom css-t1nuxs" style="margin-top:24px">index.js</h5>
<pre><code class="language-javascript">const express = require(&quot;express&quot;);
const { ApolloServer } = require(&quot;apollo-server-express&quot;);
const cors = require(&quot;cors&quot;);
const schema = require(&quot;./schema&quot;);
const bodyParser = require(&quot;body-parser&quot;);

const app = express();
app.use(cors());
app.use(bodyParser.json());

const server = new ApolloServer({
  playground: {
    endpoint: &quot;/api&quot;,
    settings: {
      &quot;editor.cursorShape&quot;: &quot;block&quot;,
      &quot;editor.cursorColor&quot;: &quot;#000&quot;,
      &quot;editor.theme&quot;: &quot;light&quot;,
    },
  },
  schema,
});

server.applyMiddleware({ app, path: &quot;/api&quot; });

app.listen(3000, () =&gt; {
  console.log(&quot;Song services listening to 3000...&quot;);
});
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">We create a simple express service using apollo engine to expose both the api and the playground to tests our api.</p>
<pre><code class="language-shell">node index.js
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">and open the <a href="http://localhost:3000">songs api</a>
You will see the playground, so you can run the first query:</p>
<pre><code class="language-graphql">{
  songs {
    id
    title
  }
}
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">you should be able to see the results.</p>
<h4 class="MuiTypography-root MuiTypography-h4 MuiTypography-gutterBottom css-gtvj52" style="margin-top:24px">Creating the movies service</h4>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">We are going to follow the same process. From the root of our project:</p>
<pre><code class="language-shell">mkdir movies
cd movies
touch index.js
touch schema.js
npm init -y
npm install express graphql apollo-server-express body-parser graphql-tag
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">index.js will be similar to the previous one. Only the port number needs to be different</p>
<pre><code class="language-javascript">const express = require(&quot;express&quot;);
const { ApolloServer } = require(&quot;apollo-server-express&quot;);
const cors = require(&quot;cors&quot;);
const schema = require(&quot;./schema&quot;);
const bodyParser = require(&quot;body-parser&quot;);

const app = express();
app.use(cors());
app.use(bodyParser.json());

const server = new ApolloServer({
  playground: {
    endpoint: &quot;/api&quot;,
    settings: {
      &quot;editor.cursorShape&quot;: &quot;block&quot;,
      &quot;editor.cursorColor&quot;: &quot;#000&quot;,
      &quot;editor.theme&quot;: &quot;light&quot;,
    },
  },
  schema,
});

server.applyMiddleware({ app, path: &quot;/api&quot; });

app.listen(3001, () =&gt; {
  console.log(&quot;Movie services listening to 3001...&quot;);
});
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">Schema will be very similar:</p>
<pre><code class="language-javascript">const { makeExecutableSchema } = require(&quot;graphql-tools&quot;);
const gql = require(&quot;graphql-tag&quot;);

const movies = [
  { id: 1, title: &quot;The Bodyguard&quot;, mainSongId: 1 },
  { id: 2, title: &quot;8 Mile&quot;, mainSongId: 2 },
  { id: 3, title: &quot;Rocky III&quot;, mainSongId: 3 },
  { id: 4, title: &quot;Men in Black&quot;, mainSongId: 4 },
  { id: 5, title: &quot;Back to the Future&quot;, mainSongId: 5 },
  { id: 6, title: &quot;Titanic&quot;, mainSongId: 6 },
];

const typeDefs = gql`
  type Query {
    movies: [Movie]
    movie(movieId: ID!): Movie
  }
  type Movie {
    id: ID!
    title: String!
    mainSongId: ID!
  }
`;

const resolvers = {
  Query: {
    movies: () =&gt; {
      return movies;
    },
    movie(parent, args, context, info) {
      return movies.find((movie) =&gt; movie.id === Number(args.movieId));
    },
  },
};

module.exports = makeExecutableSchema({
  typeDefs,
  resolvers,
});
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">The difference is that movie has a reference to songs. Specifically mainSongId. Since both services are isolated and are autonomous, movie service does not know where songs service is, or what data a songs holds. Only knows that a movie has a main song and it holds its ID.</p>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">If we run the project in the same way</p>
<pre><code class="language-shell">node index.js
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">we can see the <a href="http://localhost:3001">playground</a> and run our test queries.</p>
<h4 class="MuiTypography-root MuiTypography-h4 MuiTypography-gutterBottom css-gtvj52" style="margin-top:24px">Let&#x27;s start the interesting part. Our Api gateway</h4>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">We are going to create the same files. From project root:</p>
<pre><code class="language-shell">mkdir apigateway
cd apigateway
touch index.js
touch schema.js
npm init -y
npm install express graphql apollo-server-express body-parser graphql-tag apollo-link-http node-fetch
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">The schema will created based on the schemas of the other services, so we are going to stitch and expose them in the api gateway.</p>
<h5 class="MuiTypography-root MuiTypography-h5 MuiTypography-gutterBottom css-t1nuxs" style="margin-top:24px">schema.js</h5>
<pre><code class="language-javascript">const {
  introspectSchema,
  makeRemoteExecutableSchema,
  mergeSchemas,
} = require(&quot;graphql-tools&quot;);
const { createHttpLink } = require(&quot;apollo-link-http&quot;);
const fetch = require(&quot;node-fetch&quot;);

const MoviesUrl = &quot;http://localhost:3001/api&quot;;
const SongsUrl = &quot;http://localhost:3000/api&quot;;

async function createServiceSchema(url) {
  const link = createHttpLink({
    uri: url,
    fetch,
  });
  const schema = await introspectSchema(link);
  return makeRemoteExecutableSchema({
    schema,
    link,
  });
}

async function createSchemas() {
  const movieSchema = await createServiceSchema(SongsUrl);
  const songsSchema = await createServiceSchema(MoviesUrl);

  return mergeSchemas({ schemas: [songsSchema, movieSchema] });
}

module.exports = createSchemas();
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">As you can see in the code, the schema is generated by requesting the schemas of both APIs and merging them.
One difference is, now we need to request this data before being able to start the apigateway, so the index.js will be slightly different:</p>
<pre><code class="language-javascript">const express = require(&quot;express&quot;);
const { ApolloServer } = require(&quot;apollo-server-express&quot;);
const cors = require(&quot;cors&quot;);
const createSchema = require(&quot;./schema&quot;);
const bodyParser = require(&quot;body-parser&quot;);

const app = express();
app.use(cors());
app.use(bodyParser.json());

createSchema.then((schema) =&gt; {
  const server = new ApolloServer({
    playground: {
      endpoint: &quot;/api&quot;,
      settings: {
        &quot;editor.cursorShape&quot;: &quot;block&quot;,
        &quot;editor.cursorColor&quot;: &quot;#000&quot;,
        &quot;editor.theme&quot;: &quot;light&quot;,
      },
    },
    schema,
  });

  server.applyMiddleware({ app, path: &quot;/api&quot; });

  app.listen(4000, () =&gt; {
    console.log(&quot;Graphql listening to 4000...&quot;);
  });
});
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">Before starting the listener, the schema is requested and merged so we can expose it in our api.
We need to run the previous services in order to be able to execute this one. From the root of the project:</p>
<pre><code class="language-shell">node movies/index.js &amp;
node songs/index.js &amp;
node apigateway/index.js
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">If we go to the api gateway playground we can query movies and songs in the same query:</p>
<pre><code class="language-graphql">{
  movies {
    id
    title
    mainSongId
  }

  songs {
    id
    title
  }
}
</code></pre>
<p class="MuiTypography-root MuiTypography-body1 MuiTypography-paragraph css-wje1bd" style="text-align:justify">This was an introduction to schema stitching. In part 2 I will show some more concepts and real case scenarios like extending the services&#x27; schema in the api gateway with custom resolvers, how to optimize by using dataloaders.
If you have any questions about graphql schema stitching or about api gateway in general, please add your comment or contact me.</p></div></div></div></div></div><footer class="jss6"><style data-emotion="css 1qsxih2">.css-1qsxih2{width:100%;margin-left:auto;box-sizing:border-box;margin-right:auto;display:block;padding-left:16px;padding-right:16px;}@media (min-width:600px){.css-1qsxih2{padding-left:24px;padding-right:24px;}}@media (min-width:1200px){.css-1qsxih2{max-width:1200px;}}</style><div class="MuiContainer-root MuiContainer-maxWidthLg css-1qsxih2"><style data-emotion="css 1is0dyx">.css-1is0dyx{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;text-align:center;color:inherit;}</style><p class="MuiTypography-root MuiTypography-body2 MuiTypography-alignCenter css-1is0dyx">Copyright © <!-- -->tonitienda <!-- -->2022<!-- -->.</p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Graphql Schema Stitching","date":"2019-04-26","description":"What Graphql schema stitching is and how it can help us","thumbnail":{"url":"/images/graphql-schema-stitching.jpeg","attribution":{"name":"Aneta Pawlik","url":"https://unsplash.com/@anetakpawlik?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText"}},"tags":["javascript","graphql","api"],"filePath":"graphql-schema-stitching.mdx","slug":"graphql-schema-stitching","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    h4: \"h4\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Graphql Schema Stitching\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I am going to write a short (?) post about how to create a simple API Gateway that exposes two services using Graphql Stitching. I am assuming some knowledge about graphql and Apollo Server.\\nWe will use express, nodejs and apollo for the service and a technique called schema stitching.\\nIf you want to learn more about Graphql you can go to the official site.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Why do we need Api gateways and schema stitching\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I will write a whole post about the reasons we had to use Graphql in our services and in our Api Gateway.\\nHere I am offering a short explanation:\\nIn real world scenarios we are creating independent and autonomous (micro)services. The less data they share, the less they need to call each other and the less coupled they are, the better.\\nMany times a service manages entities (or parts of entities) that hold an id about another entity but does not need to know more details. For example an inventory service might manage productID and available units, but does not need to know about the name of the product or about its price.\\nInventory service will be able to run all its operations and apply the rules it manages without requesting information to any other service.\\nUsers, on the other hand, will need to see this scattered data together in one screen. In order to avoid too many requests from the UI, an API Gateway can offer a single endpoint where UI can request the data needed for a specific functionality/screen in one request, and the Gateway can orchestrate the calls to other services, cache results if needed, etc.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Let's start working\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's create a folder as the root for our project:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-shell\",\n        children: \"mkdir graphql-stitching\\ncd graphql-stitching\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Creating the songs service\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We are going to create a simple service that offers data about songs.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-shell\",\n        children: \"mkdir songs\\ncd songs\\nnpm init -y\\nnpm install express graphql apollo-server-express body-parser\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We are going to create our schema first:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-shell\",\n        children: \"touch schema.js\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"schema.js\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"const { makeExecutableSchema } = require(\\\"graphql-tools\\\");\\nconst gql = require(\\\"graphql-tag\\\");\\n\\nconst songs = [\\n  { id: 1, title: \\\"I will always love you\\\" },\\n  { id: 2, title: \\\"Lose yourself\\\" },\\n  { id: 3, title: \\\"Eye of the tiger\\\" },\\n  { id: 4, title: \\\"Men in Black\\\" },\\n  { id: 5, title: \\\"The power of love\\\" },\\n  { id: 6, title: \\\"My Heart will go on\\\" },\\n];\\n\\nconst typeDefs = gql`\\n  type Query {\\n    songs: [Song]\\n    song(songId: ID!): Song\\n  }\\n  type Song {\\n    id: ID\\n    title: String\\n  }\\n`;\\n\\nconst resolvers = {\\n  Query: {\\n    songs: () =\u003e {\\n      return songs;\\n    },\\n    song(parent, args, context, info) {\\n      return songs.find((song) =\u003e song.id === Number(args.songId));\\n    },\\n  },\\n};\\n\\nmodule.exports = makeExecutableSchema({\\n  typeDefs,\\n  resolvers,\\n});\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We are defining a list of songs.\\nThe type Song (id, title) and two queries for getting all songs and one song by id.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's create the api:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-shell\",\n        children: \"touch index.js\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"index.js\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"const express = require(\\\"express\\\");\\nconst { ApolloServer } = require(\\\"apollo-server-express\\\");\\nconst cors = require(\\\"cors\\\");\\nconst schema = require(\\\"./schema\\\");\\nconst bodyParser = require(\\\"body-parser\\\");\\n\\nconst app = express();\\napp.use(cors());\\napp.use(bodyParser.json());\\n\\nconst server = new ApolloServer({\\n  playground: {\\n    endpoint: \\\"/api\\\",\\n    settings: {\\n      \\\"editor.cursorShape\\\": \\\"block\\\",\\n      \\\"editor.cursorColor\\\": \\\"#000\\\",\\n      \\\"editor.theme\\\": \\\"light\\\",\\n    },\\n  },\\n  schema,\\n});\\n\\nserver.applyMiddleware({ app, path: \\\"/api\\\" });\\n\\napp.listen(3000, () =\u003e {\\n  console.log(\\\"Song services listening to 3000...\\\");\\n});\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We create a simple express service using apollo engine to expose both the api and the playground to tests our api.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-shell\",\n        children: \"node index.js\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"and open the \", _jsx(\"a\", {\n        href: \"http://localhost:3000\",\n        children: \"songs api\"\n      }), \"\\nYou will see the playground, so you can run the first query:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-graphql\",\n        children: \"{\\n  songs {\\n    id\\n    title\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"you should be able to see the results.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Creating the movies service\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We are going to follow the same process. From the root of our project:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-shell\",\n        children: \"mkdir movies\\ncd movies\\ntouch index.js\\ntouch schema.js\\nnpm init -y\\nnpm install express graphql apollo-server-express body-parser graphql-tag\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"index.js will be similar to the previous one. Only the port number needs to be different\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"const express = require(\\\"express\\\");\\nconst { ApolloServer } = require(\\\"apollo-server-express\\\");\\nconst cors = require(\\\"cors\\\");\\nconst schema = require(\\\"./schema\\\");\\nconst bodyParser = require(\\\"body-parser\\\");\\n\\nconst app = express();\\napp.use(cors());\\napp.use(bodyParser.json());\\n\\nconst server = new ApolloServer({\\n  playground: {\\n    endpoint: \\\"/api\\\",\\n    settings: {\\n      \\\"editor.cursorShape\\\": \\\"block\\\",\\n      \\\"editor.cursorColor\\\": \\\"#000\\\",\\n      \\\"editor.theme\\\": \\\"light\\\",\\n    },\\n  },\\n  schema,\\n});\\n\\nserver.applyMiddleware({ app, path: \\\"/api\\\" });\\n\\napp.listen(3001, () =\u003e {\\n  console.log(\\\"Movie services listening to 3001...\\\");\\n});\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Schema will be very similar:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"const { makeExecutableSchema } = require(\\\"graphql-tools\\\");\\nconst gql = require(\\\"graphql-tag\\\");\\n\\nconst movies = [\\n  { id: 1, title: \\\"The Bodyguard\\\", mainSongId: 1 },\\n  { id: 2, title: \\\"8 Mile\\\", mainSongId: 2 },\\n  { id: 3, title: \\\"Rocky III\\\", mainSongId: 3 },\\n  { id: 4, title: \\\"Men in Black\\\", mainSongId: 4 },\\n  { id: 5, title: \\\"Back to the Future\\\", mainSongId: 5 },\\n  { id: 6, title: \\\"Titanic\\\", mainSongId: 6 },\\n];\\n\\nconst typeDefs = gql`\\n  type Query {\\n    movies: [Movie]\\n    movie(movieId: ID!): Movie\\n  }\\n  type Movie {\\n    id: ID!\\n    title: String!\\n    mainSongId: ID!\\n  }\\n`;\\n\\nconst resolvers = {\\n  Query: {\\n    movies: () =\u003e {\\n      return movies;\\n    },\\n    movie(parent, args, context, info) {\\n      return movies.find((movie) =\u003e movie.id === Number(args.movieId));\\n    },\\n  },\\n};\\n\\nmodule.exports = makeExecutableSchema({\\n  typeDefs,\\n  resolvers,\\n});\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The difference is that movie has a reference to songs. Specifically mainSongId. Since both services are isolated and are autonomous, movie service does not know where songs service is, or what data a songs holds. Only knows that a movie has a main song and it holds its ID.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If we run the project in the same way\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-shell\",\n        children: \"node index.js\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"we can see the \", _jsx(\"a\", {\n        href: \"http://localhost:3001\",\n        children: \"playground\"\n      }), \" and run our test queries.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Let's start the interesting part. Our Api gateway\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We are going to create the same files. From project root:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-shell\",\n        children: \"mkdir apigateway\\ncd apigateway\\ntouch index.js\\ntouch schema.js\\nnpm init -y\\nnpm install express graphql apollo-server-express body-parser graphql-tag apollo-link-http node-fetch\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The schema will created based on the schemas of the other services, so we are going to stitch and expose them in the api gateway.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"schema.js\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"const {\\n  introspectSchema,\\n  makeRemoteExecutableSchema,\\n  mergeSchemas,\\n} = require(\\\"graphql-tools\\\");\\nconst { createHttpLink } = require(\\\"apollo-link-http\\\");\\nconst fetch = require(\\\"node-fetch\\\");\\n\\nconst MoviesUrl = \\\"http://localhost:3001/api\\\";\\nconst SongsUrl = \\\"http://localhost:3000/api\\\";\\n\\nasync function createServiceSchema(url) {\\n  const link = createHttpLink({\\n    uri: url,\\n    fetch,\\n  });\\n  const schema = await introspectSchema(link);\\n  return makeRemoteExecutableSchema({\\n    schema,\\n    link,\\n  });\\n}\\n\\nasync function createSchemas() {\\n  const movieSchema = await createServiceSchema(SongsUrl);\\n  const songsSchema = await createServiceSchema(MoviesUrl);\\n\\n  return mergeSchemas({ schemas: [songsSchema, movieSchema] });\\n}\\n\\nmodule.exports = createSchemas();\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As you can see in the code, the schema is generated by requesting the schemas of both APIs and merging them.\\nOne difference is, now we need to request this data before being able to start the apigateway, so the index.js will be slightly different:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"const express = require(\\\"express\\\");\\nconst { ApolloServer } = require(\\\"apollo-server-express\\\");\\nconst cors = require(\\\"cors\\\");\\nconst createSchema = require(\\\"./schema\\\");\\nconst bodyParser = require(\\\"body-parser\\\");\\n\\nconst app = express();\\napp.use(cors());\\napp.use(bodyParser.json());\\n\\ncreateSchema.then((schema) =\u003e {\\n  const server = new ApolloServer({\\n    playground: {\\n      endpoint: \\\"/api\\\",\\n      settings: {\\n        \\\"editor.cursorShape\\\": \\\"block\\\",\\n        \\\"editor.cursorColor\\\": \\\"#000\\\",\\n        \\\"editor.theme\\\": \\\"light\\\",\\n      },\\n    },\\n    schema,\\n  });\\n\\n  server.applyMiddleware({ app, path: \\\"/api\\\" });\\n\\n  app.listen(4000, () =\u003e {\\n    console.log(\\\"Graphql listening to 4000...\\\");\\n  });\\n});\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Before starting the listener, the schema is requested and merged so we can expose it in our api.\\nWe need to run the previous services in order to be able to execute this one. From the root of the project:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-shell\",\n        children: \"node movies/index.js \u0026\\nnode songs/index.js \u0026\\nnode apigateway/index.js\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If we go to the api gateway playground we can query movies and songs in the same query:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-graphql\",\n        children: \"{\\n  movies {\\n    id\\n    title\\n    mainSongId\\n  }\\n\\n  songs {\\n    id\\n    title\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This was an introduction to schema stitching. In part 2 I will show some more concepts and real case scenarios like extending the services' schema in the api gateway with custom resolvers, how to optimize by using dataloaders.\\nIf you have any questions about graphql schema stitching or about api gateway in general, please add your comment or contact me.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"markdown":"# Graphql Schema Stitching\n\nI am going to write a short (?) post about how to create a simple API Gateway that exposes two services using Graphql Stitching. I am assuming some knowledge about graphql and Apollo Server.\nWe will use express, nodejs and apollo for the service and a technique called schema stitching.\nIf you want to learn more about Graphql you can go to the official site.\n\n## Why do we need Api gateways and schema stitching\n\nI will write a whole post about the reasons we had to use Graphql in our services and in our Api Gateway.\nHere I am offering a short explanation:\nIn real world scenarios we are creating independent and autonomous (micro)services. The less data they share, the less they need to call each other and the less coupled they are, the better.\nMany times a service manages entities (or parts of entities) that hold an id about another entity but does not need to know more details. For example an inventory service might manage productID and available units, but does not need to know about the name of the product or about its price.\nInventory service will be able to run all its operations and apply the rules it manages without requesting information to any other service.\nUsers, on the other hand, will need to see this scattered data together in one screen. In order to avoid too many requests from the UI, an API Gateway can offer a single endpoint where UI can request the data needed for a specific functionality/screen in one request, and the Gateway can orchestrate the calls to other services, cache results if needed, etc.\n\n## Let\u0026#x27;s start working\n\nLet\u0026#x27;s create a folder as the root for our project:\n\n```shell\nmkdir graphql-stitching\ncd graphql-stitching\n```\n\n## Creating the songs service\n\nWe are going to create a simple service that offers data about songs.\n\n```shell\nmkdir songs\ncd songs\nnpm init -y\nnpm install express graphql apollo-server-express body-parser\n```\n\nWe are going to create our schema first:\n\n```shell\ntouch schema.js\n```\n\n#### schema.js\n\n```javascript\nconst { makeExecutableSchema } = require(\"graphql-tools\");\nconst gql = require(\"graphql-tag\");\n\nconst songs = [\n  { id: 1, title: \"I will always love you\" },\n  { id: 2, title: \"Lose yourself\" },\n  { id: 3, title: \"Eye of the tiger\" },\n  { id: 4, title: \"Men in Black\" },\n  { id: 5, title: \"The power of love\" },\n  { id: 6, title: \"My Heart will go on\" },\n];\n\nconst typeDefs = gql`\n  type Query {\n    songs: [Song]\n    song(songId: ID!): Song\n  }\n  type Song {\n    id: ID\n    title: String\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    songs: () =\u003e {\n      return songs;\n    },\n    song(parent, args, context, info) {\n      return songs.find((song) =\u003e song.id === Number(args.songId));\n    },\n  },\n};\n\nmodule.exports = makeExecutableSchema({\n  typeDefs,\n  resolvers,\n});\n```\n\nWe are defining a list of songs.\nThe type Song (id, title) and two queries for getting all songs and one song by id.\n\nLet\u0026#x27;s create the api:\n\n```shell\ntouch index.js\n```\n\n### index.js\n\n```javascript\nconst express = require(\"express\");\nconst { ApolloServer } = require(\"apollo-server-express\");\nconst cors = require(\"cors\");\nconst schema = require(\"./schema\");\nconst bodyParser = require(\"body-parser\");\n\nconst app = express();\napp.use(cors());\napp.use(bodyParser.json());\n\nconst server = new ApolloServer({\n  playground: {\n    endpoint: \"/api\",\n    settings: {\n      \"editor.cursorShape\": \"block\",\n      \"editor.cursorColor\": \"#000\",\n      \"editor.theme\": \"light\",\n    },\n  },\n  schema,\n});\n\nserver.applyMiddleware({ app, path: \"/api\" });\n\napp.listen(3000, () =\u003e {\n  console.log(\"Song services listening to 3000...\");\n});\n```\n\nWe create a simple express service using apollo engine to expose both the api and the playground to tests our api.\n\n```shell\nnode index.js\n```\n\nand open the \u003ca href=\"http://localhost:3000\"\u003esongs api\u003c/a\u003e\nYou will see the playground, so you can run the first query:\n\n```graphql\n{\n  songs {\n    id\n    title\n  }\n}\n```\n\nyou should be able to see the results.\n\n## Creating the movies service\n\nWe are going to follow the same process. From the root of our project:\n\n```shell\nmkdir movies\ncd movies\ntouch index.js\ntouch schema.js\nnpm init -y\nnpm install express graphql apollo-server-express body-parser graphql-tag\n```\n\nindex.js will be similar to the previous one. Only the port number needs to be different\n\n```javascript\nconst express = require(\"express\");\nconst { ApolloServer } = require(\"apollo-server-express\");\nconst cors = require(\"cors\");\nconst schema = require(\"./schema\");\nconst bodyParser = require(\"body-parser\");\n\nconst app = express();\napp.use(cors());\napp.use(bodyParser.json());\n\nconst server = new ApolloServer({\n  playground: {\n    endpoint: \"/api\",\n    settings: {\n      \"editor.cursorShape\": \"block\",\n      \"editor.cursorColor\": \"#000\",\n      \"editor.theme\": \"light\",\n    },\n  },\n  schema,\n});\n\nserver.applyMiddleware({ app, path: \"/api\" });\n\napp.listen(3001, () =\u003e {\n  console.log(\"Movie services listening to 3001...\");\n});\n```\n\nSchema will be very similar:\n\n```javascript\nconst { makeExecutableSchema } = require(\"graphql-tools\");\nconst gql = require(\"graphql-tag\");\n\nconst movies = [\n  { id: 1, title: \"The Bodyguard\", mainSongId: 1 },\n  { id: 2, title: \"8 Mile\", mainSongId: 2 },\n  { id: 3, title: \"Rocky III\", mainSongId: 3 },\n  { id: 4, title: \"Men in Black\", mainSongId: 4 },\n  { id: 5, title: \"Back to the Future\", mainSongId: 5 },\n  { id: 6, title: \"Titanic\", mainSongId: 6 },\n];\n\nconst typeDefs = gql`\n  type Query {\n    movies: [Movie]\n    movie(movieId: ID!): Movie\n  }\n  type Movie {\n    id: ID!\n    title: String!\n    mainSongId: ID!\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    movies: () =\u003e {\n      return movies;\n    },\n    movie(parent, args, context, info) {\n      return movies.find((movie) =\u003e movie.id === Number(args.movieId));\n    },\n  },\n};\n\nmodule.exports = makeExecutableSchema({\n  typeDefs,\n  resolvers,\n});\n```\n\nThe difference is that movie has a reference to songs. Specifically mainSongId. Since both services are isolated and are autonomous, movie service does not know where songs service is, or what data a songs holds. Only knows that a movie has a main song and it holds its ID.\n\nIf we run the project in the same way\n\n```shell\nnode index.js\n```\n\nwe can see the \u003ca href=\"http://localhost:3001\"\u003eplayground\u003c/a\u003e and run our test queries.\n\n## Let\u0026#x27;s start the interesting part. Our Api gateway\n\nWe are going to create the same files. From project root:\n\n```shell\nmkdir apigateway\ncd apigateway\ntouch index.js\ntouch schema.js\nnpm init -y\nnpm install express graphql apollo-server-express body-parser graphql-tag apollo-link-http node-fetch\n```\n\nThe schema will created based on the schemas of the other services, so we are going to stitch and expose them in the api gateway.\n\n### schema.js\n\n```javascript\nconst {\n  introspectSchema,\n  makeRemoteExecutableSchema,\n  mergeSchemas,\n} = require(\"graphql-tools\");\nconst { createHttpLink } = require(\"apollo-link-http\");\nconst fetch = require(\"node-fetch\");\n\nconst MoviesUrl = \"http://localhost:3001/api\";\nconst SongsUrl = \"http://localhost:3000/api\";\n\nasync function createServiceSchema(url) {\n  const link = createHttpLink({\n    uri: url,\n    fetch,\n  });\n  const schema = await introspectSchema(link);\n  return makeRemoteExecutableSchema({\n    schema,\n    link,\n  });\n}\n\nasync function createSchemas() {\n  const movieSchema = await createServiceSchema(SongsUrl);\n  const songsSchema = await createServiceSchema(MoviesUrl);\n\n  return mergeSchemas({ schemas: [songsSchema, movieSchema] });\n}\n\nmodule.exports = createSchemas();\n```\n\nAs you can see in the code, the schema is generated by requesting the schemas of both APIs and merging them.\nOne difference is, now we need to request this data before being able to start the apigateway, so the index.js will be slightly different:\n\n```javascript\nconst express = require(\"express\");\nconst { ApolloServer } = require(\"apollo-server-express\");\nconst cors = require(\"cors\");\nconst createSchema = require(\"./schema\");\nconst bodyParser = require(\"body-parser\");\n\nconst app = express();\napp.use(cors());\napp.use(bodyParser.json());\n\ncreateSchema.then((schema) =\u003e {\n  const server = new ApolloServer({\n    playground: {\n      endpoint: \"/api\",\n      settings: {\n        \"editor.cursorShape\": \"block\",\n        \"editor.cursorColor\": \"#000\",\n        \"editor.theme\": \"light\",\n      },\n    },\n    schema,\n  });\n\n  server.applyMiddleware({ app, path: \"/api\" });\n\n  app.listen(4000, () =\u003e {\n    console.log(\"Graphql listening to 4000...\");\n  });\n});\n```\n\nBefore starting the listener, the schema is requested and merged so we can expose it in our api.\nWe need to run the previous services in order to be able to execute this one. From the root of the project:\n\n```shell\nnode movies/index.js \u0026\nnode songs/index.js \u0026\nnode apigateway/index.js\n```\n\nIf we go to the api gateway playground we can query movies and songs in the same query:\n\n```graphql\n{\n  movies {\n    id\n    title\n    mainSongId\n  }\n\n  songs {\n    id\n    title\n  }\n}\n```\n\nThis was an introduction to schema stitching. In part 2 I will show some more concepts and real case scenarios like extending the services\u0026#x27; schema in the api gateway with custom resolvers, how to optimize by using dataloaders.\nIf you have any questions about graphql schema stitching or about api gateway in general, please add your comment or contact me.\n"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"graphql-schema-stitching"},"buildId":"bI8TJphBv-0RVteqVUZQm","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>