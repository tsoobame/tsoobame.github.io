

<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="/static/styles.css" rel="stylesheet" />
    <title></title>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id="
    ></script>
    <script>
      window.dataLayer = window.dataLayer || []
      function gtag() {
        dataLayer.push(arguments)
      }
      gtag("js", new Date())
      gtag("config", "", { page_path: window.location.pathname })
    </script>
  </head>
  <body>
    <main>
      <header>
        <nav>
          
          <h2 style="width: 12rem; text-align: left">
            
            <a color="inherit" href="/blog"></a>
          </h2>
          <div class="navbar-links">
            
            <button
              tabindex="0"
              type="button"
              
            >
              <a href="/projects" color="inherit">projects</a>
            </button>
            
            <button
              tabindex="0"
              type="button"
              class="active"
              
            >
              <a href="/blog" color="inherit">blog</a>
            </button>
            
          </div>
        </nav>
      </header>

      <div class="container mx-auto px-4 pt-8"><div class="mb-8">
  
  <div class="mb-4 text-end">
    <img
      src="https://res.cloudinary.com/ddkok43g3/image/upload/w_auto,h_400,c_fill,g_auto,q_auto,f_auto/resume-driven-development.jpg"
      alt=""
      class="w-full h-[400px] object-cover rounded"
    />

    
    <div class="mt-2">
      
        <a
          href="tags/software.html"
          class="inline-block bg-[rgb(0,119,151)] text-white text-xs font-medium px-2 py-1 rounded me-1"
        >
          software
        </a>
      
        <a
          href="tags/design.html"
          class="inline-block bg-[rgb(0,119,151)] text-white text-xs font-medium px-2 py-1 rounded me-1"
        >
          design
        </a>
      
        <a
          href="tags/project.html"
          class="inline-block bg-[rgb(0,119,151)] text-white text-xs font-medium px-2 py-1 rounded me-1"
        >
          project
        </a>
      
        <a
          href="tags/boring.html"
          class="inline-block bg-[rgb(0,119,151)] text-white text-xs font-medium px-2 py-1 rounded me-1"
        >
          boring
        </a>
      
    </div>

    
    <small class="text-gray-500 text-sm mt-2 inline-block">
      Photo by
      <a
        href="https://unsplash.com/@churchoftodd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText"
        class="underline hover:text-[rgb(0,119,151)]"
        target="_blank"
        rel="noopener noreferrer"
      >
        "Todd Kent"
      </a>
    </small>
  </div>

  
  <article class="post-content">
    <h1 id="resume-driven-development">Resume Driven Development</h1>
<p>As software engineers we want to utilize the most effective tools, patterns and methodologies to fulfill our clients needs.</p>
<p>A common mantra in our industry is <code>&quot;Use the right tool for the job&quot;</code>.  This idea gained momentum with the microservices hype, leading to a surge in polyglot programming, persistence, and more. This diversification has seen companies adopting a myriad of programming languages, persistence layers, frameworks, and tools in pursuit of the perfect solution, often overlooking the adequacy of existing tools within their stack.</p>
<p>A few years ago, I also fell into the trap of microservices and technology proliferation. Fortunately, the small size of our team and our codebase made the damage reversible and manageable.</p>
<p>This experience made me pause and take time for introspection. Was I genuinely choosing the right tools for the project or was I unconsciously choosing shiny tools that would make my resume more interesting?<br />
Despite my best intentions, I couldn't completely disregard the personal desire for learning about them.</p>
<p>This realization led me to adopt a more judicious and methodical approach to integrating new technologies into our projects</p>
<h2 id="adding-a-new-tech-to-the-stack">Adding a new tech to the stack</h2>
<p>Introducing new technology—be it a language, framework, persistence layer, message broker, etc.—requires a learning curve. We love exploring new tools and the novelty of solving use cases and enabling features, needed or not. We tend to underestimate the learning curve of understanding how they fail, when they tend to fail, how the errors are discovered or monitored, and designing how to recover from those errors.</p>
<p>The real test often comes after deployment, challenging us to reassess the need for that new technology after we've already introduced it.</p>
<p>Thus, I urge you to think twice before expanding your tech stack.</p>
<h2 id="chosing-technology">Chosing technology</h2>
<p>During the introspection period I stumbled into thought-provoking piece titled <a href="https://mcfunley.com/choose-boring-technology">Chose boring technology</a>, which eloquently argued against the rush to adopt new technologies and embrace the boring ones, understanding <code>boring</code> as the ones we know and understand well and, therefore, don't give any surprises.</p>
<p>If your project already has an established tech stack, here are some considerations before introducing new technology:</p>
<h3 id="can-the-existing-tech-stack-address-the-problem">Can the existing tech stack address the problem?</h3>
<p>Design the solution with the current stack, without adding any new technology. If the design is feasible, it can be the baseline for the decision.</p>
<p>Some challenges for the design:</p>
<ul>
<li>Would it be compliant with the non-functional requirements or SLAs?</li>
<li>How complex or maintailable is the implementation?</li>
</ul>
<h3 id="future-project-features">Future project features</h3>
<p>Assess whether the planned features or project direction could benefit from introducing the tech stack.<br />
For example some technologies can act as enablers for future features.</p>
<h3 id="team-expertise">Team expertise</h3>
<p>Consider the team's familiarity with the new technology and the implications of acquiring or hiring expertise.</p>
<h2 id="real-world-naive-example">Real-World naive Example</h2>
<p>Let's consider a hypothetical project with the following tech stack:</p>
<ul>
<li>React in front end</li>
<li>Nodejs in the backend (with Express)</li>
<li>Postgres as the main database</li>
</ul>
<p>Your data is structured and fits well in a relational database. Your application is mostly a CRUD application.</p>
<p>Life is good, and things are working as expected until a couple of new features appear in the backlog.</p>
<h3 id="feature-1-integrating-unstructured-data">Feature 1: Integrating unstructured data</h3>
<p>You have a new feature that—for some reason—requires storing unstructured data. When investigating tools, you find Document DBs, one of them being MongoDB.</p>
<p>Although it would look great on your—and your team members'—resumes, you think twice, remember a blog post you read some time ago, and decide carefully. That would be the right tool for the job. But, do you really need it?</p>
<h4 id="can-the-existing-tech-stack-address-the-problem-1">Can the existing tech stack address the problem?</h4>
<p>You create a design with the current stack. After some research, you learn that Postgres supports JSON or JSONB column types that can store unstructured data. Your design includes a JSONB column in the table, and you can query it as you would with a document database.</p>
<h4 id="future-project-features-1">Future project features</h4>
<p>After scanning through the product backlog, nothing calls your attention that could break your design.</p>
<h4 id="team-expertise-1">Team expertise</h4>
<p>The team has a lot of experience with Postgres and a couple of team members are certified in MongoDB.</p>
<h4 id="decision">Decision</h4>
<p>Keeping the tech stack and using Postgres' JSONB column type seems the sensible approach.</p>
<h3 id="feature-2-real-time-notifications">Feature 2: Real-time* notifications</h3>
<p>The team is to work on a new feature that requires real-time* notifications. Some actions need to be notified to the affected users.</p>
<p>When investigating about events, real-time notifications, you find out about message brokers like NATS Server, RabbitMQ, or Kafka. You consider adding them to the tech stack. But—of course—you think twice and follow your process to make the right decision.</p>
<h4 id="can-the-existing-tech-stack-address-the-problem-2">Can the existing tech stack address the problem?</h4>
<p>After some research, you find out that PostgreSQL has LISTEN/NOTIFY that supports the Pub/Sub pattern and could be used to subscribe to changes and produce the right notifications. You also read about the outpost pattern that could be used for the feature at hand.</p>
<p>You create two designs, one using LISTEN/NOTIFY and the other using the outpost pattern.</p>
<h5 id="listennotify">LISTEN/NOTIFY</h5>
<p>This approach could work and your design seems correct.<br />
One of the drawbacks is the performance of the database. The more subscribers, the more load on the database. That might impact your queries and the performance of the website.</p>
<h5 id="outpost-pattern">Outpost pattern</h5>
<p>Agains, this approach could work and seems elegant and simple.<br />
One of the drawbacks is that you would need to add a new table for each subscription type (push notifications, emails, etc).<br />
For the feature at hand you only need one subscription but that limitation is something to consider.</p>
<h4 id="what-other-features-are-down-the-line">What other features are down the line?</h4>
<p>Scanning through the backlog you find multiple stories related to notifications, real-time updates, etc.<br />
Your choice will need to consider that shift towards real-time event-driven features.</p>
<h4 id="how-much-expertise-about-that-tool-do-we-have-in-the-team">How much expertise about that tool do we have in the team?</h4>
<p>The team has a lot of experience with Postgres but not using LISTEN/NOTIFY.<br />
Some of the team members know well RabbitMQ and/or Kafka.</p>
<h4 id="decision-1">Decision</h4>
<p>You decide that using Postgres alone is not suitable for these features and the ones to come. Adding a message broker is needed and will enable more features in the future. Based on what you learn from researching PostgreSQL, you decide that a combination of the outpost pattern and a message broker is the way to go.</p>
<p>After some more research, your team decides to go with RabbitMQ.</p>
<h2 id="conclusion">Conclusion</h2>
<p>These examples, while simplified, illustrate the essence of deliberate technology selection. We're naturally drawn to the latest innovations, eager to explore their potential and how they might enhance our projects. But it's crucial to choose mindfully.</p>
<p>Adding a new technology to our stack should come after thoughtful consideration. Even if a tool is perfect for the job, the price of adding it to our stack might outweigh the benefits it brings.</p>
<p><a href="https://github.com/tonitienda/kadai">Personal projects</a> offer the perfect playground for experimentation, allowing us to satisfy our appetite for learning without risking the integrity of our professional endeavors. By reserving our exploratory impulses for these spaces, we can approach our work projects with a more focused and pragmatic mindset. What we learn in those personal projects can be applied to our work projects, but only after a thorough evaluation of the potential benefits and drawbacks.</p>

  </article>
  <div>
    
    
  </div>
</div>
</div>

      <footer>
        <div>
          <p>&copy; 2025 . All rights reserved.</p>
        </div>
      </footer>
    </main>
  </body>
</html>
